import pygame
import logging

from settings import *
from level import GameAudio


# Player class
class Player(pygame.sprite.Sprite):
    def __init__(self, x, y, surface, health_max) -> None:
        # need also walk_anim, attack_anim, death_anim, sounds
        """
        The Player class constructor - note that x and y is only for initialization,
        the player position will be tracked by the rect, as the class inherits from the Sprite class
        Player is added to a sprite group, which then is used for calling the draw(method)
        """
        super().__init__()

        self.screen = surface

        # TODO: fix hardcoded values
        self.health_max = health_max
        self.health_current = self.health_max

        self.invincible = False
        self.invincibility_duration = 500
        self.last_damage = 0

        from animation_data import anim

        # Setting up animations
        self.animations = {
            'idle': anim['player']['idle'],
            'walk': anim['player']['walk'],
            'attack': anim['player']['attack'],
            'death': anim['player']['death']
        }

        self.state = {
            'active': IDLE,
            'next': IDLE,
        }

        self.rects = {
            'player': pygame.Rect,  # the rect for the full player sprite
            'hitbox': pygame.Rect,  # the rect for testing collision with environment, projectiles, spells, hazards and monsters (smaller)
            'attack': pygame.Rect,  # the rect for the player attack, to test collision with monsters and projectiles
            'collide': pygame.Rect,  # the rect for testing collisions with 
        }
        
        self.animation = self.animations['walk']  # Walking by default
        self.image = self.animation.get_image()
        
        # Convert from original resolution to game resolution
        self.width = int(self.animations['walk'].ss.x_dim * self.animations['walk'].ss.scale * 1.4 )  # we make the sprite a bit wider so we can encapsulate the attack anim without resizing
        self.height = self.animations['walk'].ss.y_dim * self.animations['walk'].ss.scale

        self.vel_x = 0  # we add and substract to this value based on keypresses
        self.vel_y = 0  # jumping or falling
        self.walking = False

        

        # The main rect for the player sprite
        self.rects['player'] = pygame.Rect(x,y, self.width, self.height)  

        # Manual adjustments of hitbox rect - as we use general draw() method from SpriteGroup(), the rect will position the surface, so need to be full size
        self.X_ADJ = self.animations['walk'].ss.scale * 44
        self.Y_ADJ = self.animations['walk'].ss.scale * 17
        x_reduction = 20   # we make the player hitbox narrower for hits and for falling
        self.rects['hitbox'] = pygame.Rect(x + x_reduction ,y, self.width - self.X_ADJ - x_reduction * 2, self.height - self.Y_ADJ)

       
        # To do efficient sprite collision check against monster groups, the hitbox need to be a full Sprite, not just a rect, with an image
        self.hitbox_sprite = pygame.sprite.Sprite()
        hitbox_image = pygame.Surface((self.width, self.height)).convert_alpha()
        hitbox_image.fill((0, 0, 0, 0))
        self.hitbox_sprite.image = hitbox_image
        self.hitbox_sprite.rect = self.rects['hitbox']

        # Setting up sound effects
        sounds = GameAudio(1)  # TODO: remove level hardcoding
        self.fx_attack = sounds.player['attack']
        self.fx_jump = sounds.player['jump']
        self.fx_die = sounds.player['die']
        self.fx_hit = sounds.player['hit']
        self.fx_attack.set_volume(0.5)
        self.fx_jump.set_volume(0.5)
        self.fx_die.set_volume(0.5)
        self.fx_hit.set_volume(0.2)
        self.fx_attack_channel = pygame.mixer.Channel(0)  # we use separate channel to avoid overlapping sounds with repeat attacks

        # Status variables
        self.turned = False  # flip sprite/animations when moving left
        self.on_ground = False  # standing on solid ground
        self.bouncing = False  # hit by something --> small bounce in the opposite direction
        self.last_env_damage = 0  # to manage frequency of damage
        self.last_attack = 0  # slowing down the attack
        self.attack_delay = 100
        self.world_x_pos = x + self.rects['player'].width / 2 # player center x position across the whole world, not just screen

    def _flash(self) -> None:   # TODO: nothing works as a new image with be generated by move() before the screen is updated
        coloured_image = pygame.Surface(self.image.get_size())
        coloured_image.fill(RED)
        
        final_image = self.image.copy()
        final_image.blit(coloured_image, (0, 0), special_flags = pygame.BLEND_MULT)
        self.image = final_image
    

    def _state_engine(self) -> None:
        """
        Manage state changes

        If state['next'] is different from state['active]...
        
        """
        if self.state['next'] != self.state['active']:

            # --> Idle
            if self.state['next'] == IDLE:
                # If we were attacking, and now we're done with the animation (if not, we ignore for now)
                if self.state['active'] == ATTACKING and self.animation.on_last_frame:
                    self.state['active'] = IDLE
                    self.animation = self.animations['idle']
                    self.animation.frame_number = 0  # important as if we're starting a new game, the animation might be in a random state
                    self.animation.active = True

                # If we were walking, and now we're done with the animation (if not, we ignore for now)
                if self.state['active'] == WALKING and self.animation.on_last_frame:
                    self.state['active'] = IDLE
                    self.animation = self.animations['idle']
                    self.animation.frame_number = 0
                    self.animation.active = True

                # If we were jumping and have landed, we switch right away
                if self.state['active'] == JUMPING and self.on_ground:
                    self.state['active'] = IDLE
                    self.animation = self.animations['idle']
                    self.animation.frame_number = 0
                    self.animation.active = True

            # --> Jumping
            if self.state['next'] == JUMPING:
                # Jumping, like attacking, interrupts anything 
                self.state['active'] = JUMPING
                self.animation = self.animations['walk']
                self.animation.frame_number = -1  # last frame of walk anim is also jump anim for stabby
                self.animation.active = False

            # --> Walking
            if self.state['next'] == WALKING:
                # If we were attacking, and now we're done with the animation (if not, we ignore for now)
                if self.state['active'] == ATTACKING and self.animation.on_last_frame:
                    self.state['active'] = WALKING
                    self.animation = self.animations['walk']
                    self.animation.frame_number = 0
                    self.animation.active = True

                # If we were idle, we start walking straight away
                if self.state['active'] == IDLE:
                    self.state['active'] = WALKING
                    self.animation = self.animations['walk']
                    self.animation.frame_number = 0
                    self.animation.active = True

                # If we were jumping, and we're bak on the ground, we start stright away
                if self.state['active'] == JUMPING and self.on_ground:
                    self.state['active'] = WALKING
                    self.animation = self.animations['walk']
                    self.animation.frame_number = 0
                    self.animation.active = True
    
            # --> Attacking 
            if self.state['next'] == ATTACKING:
                # Attack interrupts anything
                self.state['active'] = ATTACKING
                self.animation = self.animations['attack']
                self.animation.frame_number = 0
                self.animation.active = True


            # --> Dying, running through death animation until dead
            if self.state['next'] == DYING:
                self.animation = self.animations['death']
                self.animation.active = True
                self.animation.frame_number = 0
                self.state['active'] = DYING
                logging.debug('--- DYING ---')
                

            # --> Dead, of the animation has run to the end
            if self.state['next'] == DEAD:
                self.state['active'] = DEAD
                logging.debug('--- DEAD ---')
                pygame.time.wait(3000)  # we freeze the game to look at your corpse for a moment
                
    

    def get_anim_image(self) -> None:
        """ Update the image of self, which is called by SpriteGroup.draw() method 
        """
        # Once animation points to the correct state animation, we have our image
        anim_frame = self.animation.get_image().convert_alpha()
        anim_frame = pygame.transform.flip( anim_frame, self.turned, False)
        
        self.image = pygame.Surface((self.width, self.height)).convert_alpha()
        self.image.fill((0, 0, 0, 0))

        x_adjustment = 25  # to center the player image in the sprite
        y_adjustment = 0

        if self.state['active'] in (WALKING, IDLE, DYING, JUMPING):
            self.image.blit(anim_frame, (x_adjustment, y_adjustment))
        
        if self.state['active'] == ATTACKING:
            # To fit the attack animation in the sprite, the character was moved a bit, compensating
            direction = 1
            if self.turned:
                direction = -1
            ATTACK_X = 20 * direction
            ATTACK_Y = 12
            self.image.blit(anim_frame,(ATTACK_X + x_adjustment, ATTACK_Y))

    def get_input(self) -> None:
        """ Registering keypresses and triggering state changes """
        keys = pygame.key.get_pressed()

        if self.state['active'] not in (DYING, DEAD):  # we only do this if we're still alive
            if keys[pygame.K_RIGHT]:
                self.walking = 1  # right
                self.state['next'] = WALKING
                self.turned = False

            elif keys[pygame.K_LEFT]:
                self.walking = -1  # left
                self.state['next'] = WALKING
                self.turned = True

            else:
                self.walking = False
                self.state['next'] = IDLE

            if keys[pygame.K_UP] and self.on_ground:
                self.vel_y = - JUMP_HEIGHT

                self.state['next'] = JUMPING
                self.on_ground = False
                self.fx_jump.play()

            if keys[pygame.K_SPACE]:
                now = pygame.time.get_ticks()
                if now - self.last_attack > self.attack_delay:
                    self.state['next'] = ATTACKING
                    if not self.fx_attack_channel.get_busy():  # playing sound if not all channels busy
                        self.fx_attack_channel.play(self.fx_attack)
                    self.last_attack = now
                
        if keys[pygame.K_ESCAPE]:
            pygame.quit()
            exit(0)

    def hazard_damage(self, damage: int, hits_per_second:int=0) -> None:
        """ Player has been in contact with enviromnmental damage, gets damage once or frequency per second """
        now = pygame.time.get_ticks()
        if now > self.last_env_damage + 1000 / hits_per_second:
            self.fx_hit.play()
            # Adjust health and bars
            self.health_current -= damage
            if self.health_current <= 0:
                self.health_current = 0                                    
                self.state['next'] = DYING
                self._state_engine()  # we call the state engine to get an out-of-turn state update

            self.health_bar_length = int(SCREEN_WIDTH / 6 * self.health_current / 1000)
            self.last_env_damage = now


    def heal(self, damage) -> None:
        """ Player is being healed """
        self.health_current += damage
        if self.health_current > self.health_max:
            self.health_current = self.health_max
        self.health_bar_length = int(SCREEN_WIDTH / 6 * self.health_current / 1000)

    def hit(self, damage: int, turned: bool, platforms) -> None:
        """ Player has been hit by mob or projectile, gets damage and bounces backs"""
        if not self.invincible:  # we have half a sec of invincibility after damage to avoid repeat damage
            if damage:  # we also use hits without damage to bump the player
                self._flash()
                self.fx_hit.play()
                self.invincible = True  # we want 
                self.last_damage = pygame.time.get_ticks()  
                # Adjust health and bars
                self.health_current -= damage
                if self.health_current <= 0:
                    self.health_current = 0
                    self.state['next'] = DYING

                self.health_bar_length = int(SCREEN_WIDTH / 6 * self.health_current / 1000)

                self._state_engine()  # we call the state engine to get an out-of-turn state update

            if self.state['next'] != DYING:  # if we just got killed we skip the bounce
                direction = 1
                if turned:
                    direction = -1

                # Bounce back
                x_bounce = 5 * direction
                y_bounce = -15
                self.on_ground = False

                if not self.bouncing:
                    self.vel_x = x_bounce
                    self.vel_y = y_bounce
                    self.bouncing = True

                # Prevent us getting bounced inside platforms
                for platform in platforms:
                    if platform.rect.colliderect(self.rects['hitbox'].x + x_bounce, (self.rects['hitbox'].y + y_bounce) - 200, self.width - self.X_ADJ, self.height - self.Y_ADJ):
                        x_bounce = 0
                        self.vel_x = 0


    def actions(self, platforms) -> int:
        """ Movement as a result of keypresses as well as gravity and collision """
        dx = 0
        dy = 0
        scroll = 0
        
        # If we've been hit, we're invincible - check if it's time to reset
        if self.invincible and self.state['active'] not in (DYING, DEAD):
            if pygame.time.get_ticks() - self.last_damage > self.invincibility_duration:
                self.invincible = False


        # updating hitbox location to follow player sprite
        self.rects['hitbox'].center = (self.rects['player'].centerx, self.rects['player'].centery + 10) 

        # DYING
        if self.state['active'] == DYING:
            self.bouncing = False
            self.invincible = True  # prevents monsters triggering events on our corpse
            if self.animation.on_last_frame:
                self.state['next'] = DEAD

        # WALKING, JUMPING and ATTACKING: player still moves (even if attacking )
        if self.state['active'] in (WALKING, JUMPING, ATTACKING):  
            if self.walking == 1:  # right
                dx += WALKING_SPEED
                self.turned = False
            elif self.walking == -1:  # left
                dx -= WALKING_SPEED
                self.turned = True

        # JUMPING: landed yet?
        if self.state['active'] == JUMPING and self.vel_y == 0:
            self.state['next'] = IDLE
        
        # ATTACKING: make rect
        if self.state['active'] == ATTACKING:
            if self.turned:
                x = self.rects['player'].left
            else:
                x = self.rects['hitbox'].right

            self.rects['attack'] = pygame.Rect(x, self.rects['player'].top + 30, self.rects['player'].right - self.rects['hitbox'].right, 100) 
        
        # if we are NOT attacking, remove the rectangle
        else:
            self.rects['attack'] = None
        

        # Gravity
        self.vel_y += GRAVITY
        dy += self.vel_y

        # Bounce (in x-direction, y is handled by gravity)
        if self.bouncing:
            dx += self.vel_x

        # Watch screen boundaries (effectively world boundaries since the screen scrolls to world edges before player can get to end of screen)
        if self.rects['hitbox'].left + dx < 0:
            dx = - self.rects['player'].left
        if self.rects['hitbox'].right + dx > SCREEN_WIDTH:
            dx = SCREEN_WIDTH - self.rects['player'].right
        
        # Check if player has reached scroll threshold to the LEFT (and we're not on the far left) + we're walking left
        if dx < 0 and self.rects['player'].centerx <= SCROLL_THRESHOLD and self.world_x_pos > SCROLL_THRESHOLD + self.rects['hitbox'].width:
            scroll = -dx  # We scroll left by the opposite of the player's x speed
        
         # Check if player has reached scroll threshold to the right (and we're not on the far right) + we're walking right
        if dx > 0 and self.rects['player'].centerx >= SCREEN_WIDTH - SCROLL_THRESHOLD and self.world_x_pos < TILE_SIZE * MAX_COLS - SCROLL_THRESHOLD:
            scroll = -dx  # We scroll right by the opposite of the player's x speed

        # Checking vertical collision with terrain (falling)
        for platform in platforms:
            # collision in the y direction only, so instead of using self.rects['hitobx'] directly, we create
            # this temporaty rectangle with dy added for where the rectange _would_ be after the move (or we'd end up inside the platform)
            self.rects['collide'] = self.rects['hitbox'].copy() 
            self.rects['collide'].centery += dy
            
            if platform.rect.colliderect(self.rects['collide']):
                if self.rects['hitbox'].bottom < platform.rect.centery:  # Is player above platform?
                    if platform.solid == True:
                        if self.vel_y > 0:  # Is player falling?
                            dy = 0
                            self.on_ground = True
                            self.vel_y = 0
                            self.bouncing = False
                    if platform.moving == True:  # We add the travel of the platform to the x pos of the player
                        self.rect.centerx += platform.dist_player_pushed
                        platform.dist_player_pushed = 0     

                else:   # we're below the platform, abou to bump our head, so resetting vel_y to falling
                    if platform.solid == True:
                        self.vel_y = 1
            
            
            # Checking horisontal collision - walking into terrain
            if platform.rect.colliderect(self.rects['hitbox'].x + dx, self.rects['hitbox'].y, self.width - self.X_ADJ, self.height - self.Y_ADJ):
                dx = 0


        # Update rectangle position
        self.rects['player'].x += dx + scroll
        self.rects['player'].y += dy 

        self.world_x_pos += dx

        if DEBUG_HITBOXES:
           
            pygame.draw.rect(self.screen, (255,255,255,255), self.rects['player'], 2 )  # Player rect (WHITE)
            pygame.draw.rect(self.screen, (0,0,255,255), self.rects['collide'], 2 )  # Ground colliosion rect (GREEN)
            pygame.draw.rect(self.screen, (0,255,0,255), self.rects['hitbox'], 2 )  # Player hitbox (BLUE)
            if self.rects['attack']:
                pygame.draw.rect(self.screen, (255,0,0,255), self.rects['attack'], 2 )  # attack rect (RED)
            
        return scroll
 

    def update(self, platforms) -> int:
        self.get_input()
        self._state_engine()
        scroll = self.actions(platforms)
        self.rect = self.rects['player']
        self.get_anim_image()
        return scroll
        

class PlayerInOut(pygame.sprite.Sprite):
    def __init__(self, x, y, inout) -> None:
        super().__init__()

        self.inout = inout

        if self.inout == 'in':
            self.in_x = x
            self.in_y = y
        
        if self.inout == 'out':
            self.out_x = x
            self.out_y = y
        
        self.image = pygame.Surface((TILE_SIZE, TILE_SIZE))  #  empty surface
        self.rect = self.image.get_rect(center=(x + TILE_SIZE/2, y + TILE_SIZE/2))

    def update(self, scroll) -> None:
        self.rect.centerx += scroll



